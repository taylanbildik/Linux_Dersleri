<!DOCTYPE html>
<html lang="en" >

<head>

  <link href="css/mobile.css" rel="stylesheet">
  <link rel="stylesheet" href="css/bootstrap.min.css">
  <link rel="stylesheet" href="css/style.css">


</head>
<style>
mark { 
    background-color: rgba(27,31,35,.05);
    color: lightseagreen;
	font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
	font-weight: bold;
	padding-top: 1px;
	padding-bottom: 1px;
	padding-left: 4px;
    border-radius: 4px;
}					
.responsive {
    width: 100%;
    height: auto;
}
body {
  margin: 0;
  font-size: 18px;
  font-family: Arial, Helvetica, sans-serif;
}
	</style>
<body style="background-color: rgb(255, 255, 255);">

<div class="container">

  
  <nav class="navbar nav-down navbar-default navbar-fixed-top">
    <div class="container">

      

      <center><div id="sizecontroldiv" class="controlstyle">
        <a href="../index.html" class="btn btn-success navbar-btn" >Geri</a>
        <a class="btn btn-warning navbar-btn" href="#smaller">Küçült</a>
        <a class="btn btn-dark navbar-btn"  onclick="dark()">MOD</a>
        <a class="btn btn-warning navbar-btn" href="#bigger">Büyüt</a>
        <a href="../web/10.html" class="btn btn-success navbar-btn">İleri</a>

      </div>
      </center>

    </div>
  </nav>


</div>
<article id="makale" style="font-size:1em;" class="markdown-body entry-content" itemprop="text"><h1>Dosya İşlemleri</h1>
<p>Konumuz itibari ile dosyalarla epeyce haşır neşir olacağız. Yapacağımız işlemleri kısaca tanımlamak gerekirse; dosya kopyalama, taşıma, değiştirme, görüntüleme, düzenleme gibi işlemelerle dosyalar üzerinde hakimiyet kuracağız.</p>
<h2>touch</h2>
<p><strong><code>touch</code></strong> komutu bize kolaylıkla metin dosyası oluşturma imkanı tanıyor. İşte bu yüzden dosya işlemleri konumuza <strong><code>touch</code></strong> komutu ile başlamak gayet doğru bir karar olacaktır.</p>
<p>Kendimize <strong><code>touch</code></strong> komutunu kullanarak boş bir dosya oluşturmak için komut satırına <strong><code>touch dosya_ismi</code></strong> şeklinde yazmamız gerekiyor. Burada fark ettiyseniz herhangi bir uzantı girmeme gerek kalmadı. Çünkü Linux sisteminde uzantı belirtme zorunluluğu bulunmuyor. Bu durumu gözlemlemek için konsola <strong><code>touch yeni</code></strong> komutunu vererek "<strong>yeni</strong>" adından bir dosya oluşturalım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/1-min.png" class="responsive" ></p>
<p>Görüldüğü üzere dosyamız bulunduğumuz ana dizinde oluşmuş oldu. Bunu teyit etmek için de çıktıda görüldüğü gibi daha önce öğrenmiş olduğumuz listeleme görevinde olan <strong><code>ls</code></strong> komutunu kullandık.</p>
<p>Peki bir tane değil de birden fazla dosya oluşturmak istersek ? İşte bunun için de komutumuzu <strong><code>touch yeni1 yeni2 yeni3</code></strong> şeklinde yazmamız yeterli.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/2-min.png" class="responsive" ></p>
<p>Çıktıda görüldüğü gibi aynı andan 3 dosya oluşturmayı başardık.</p>
<p>Aslında <strong><code>touch</code></strong> komutunun çok farklı kullanım yöntemleri de mevcut ancak ben son olarak dosyaların tarih etiketlerini nasıl değiştirebiliriz bunu göstermek istiyorum.</p>
<p>Dosyamızın tarih etiketini düzenlemek için <strong>touch</strong> komutunun <strong><code>t</code></strong> parametresini kullanacağız. Kullanımı ise <strong><code>touch -t YYYYAAGGSSDD.SS dosya_adı</code></strong> şeklindedir.
Öncelikle dosyamızın mevcut tarih etiketine bakalım.<img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/3-min.png" class="responsive" ></p>
<p>Şimdi dosyamızın tarih etiketini daha önceki bir tarihe çevirelim.
Ben burada örnek olması açısından tarih olarak <strong>2015.01.01</strong> ve saat <strong>22:15:32</strong>  zamanlamasını kullanıyorum. Nasıl kullanıldığını daha net anlamak için örneği inceleyebilirsiniz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/4-min.png" class="responsive" ></p>
<p>Gördüğünüz gibi dosyamın tarih etiketi değişmiş oldu. Bu değişme işlemini ileri veya geri tüm tarihler için kullanabilirsiniz.</p>
<h2>cat</h2>
<p><strong><code>cat</code></strong> komutu temelde dosya içeriğini terminal ekranından okumamıza olanak sağlayan komuttur. Ancak bu komut bizlere temel işlevinin dışında da dosyalar ile ilgili pek çok işlem yapma imkanı sağlıyor. Sırasıyla bunların bazılarına göz atacağız. Ama ilk olarak temel işlevi olan terminal üzerinden dosya okuma işlevini görelim.</p>
<p>Bunun için konsola açmak istediğimiz dosyanın konumundayken <strong><code>cat açılacak_dosya</code></strong> şeklinde komut vermemiz gerek.
Ben masaüstü konumunda yer alan "<em><strong>test.txt</strong></em>" isimli dosyanın içeriğini okumak üzere konsola <strong><code>cat test.txt</code></strong> komutunu veriyorum.(Dosyayı grafik arayüzü aracılığı ile de açarak durumu kıyaslamanızı istedim.)</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/6-min.png" class="responsive" ></p>
<p>Şimdi ise tıpkı <strong><code>touch</code></strong> komutunda çoklu dosyalar ile ilgili işlem yaptığımız gibi <strong><code>cat</code></strong> komutu ile de çoklu dosya okuma işlemini gerçekleştirelim. Çoklu dosya okuma işlemi için komut satırına <strong><code> cat dosya1 dosya2 dosya3</code></strong> şeklinde okumak istediğimiz dosyaların adlarını yazıyoruz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/7-min.png" class="responsive" ></p>
<p>Dosya içeriğine yazı eklemek istersek <strong><code>cat &gt; dosya_adı</code></strong> şeklinde komut verdiğimizde, komut satırı imleci bir alt satıra geçerek bizden yazmak istediğimiz bilgiyi bekler. Yazma işlemimiz bittikten sonra kaydederek kapatmak için <strong><mark> Ctrl + D</mark></strong> tuş kombinasyonunu kullanırız. Ayrıca komutta girdiğimiz isimde bir dosya yoksa o isimde bir dosya oluşur ve girilen veriler içerisine işlenir.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/8-min.gif" class="responsive" ></p>
<p>Ancak var olan bir dosyanın adıyla bu komutu kullandıysanız ve dosya içerisinde yazı bulunuyorsa bu işlemin ardından dosyada bulunan eski veriler silinerek yalnızca girilen yeni veriler dosyaya işlenip kayıt oluyor.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/9-min.gif" class="responsive" ></p>
<p>Bizler eğer önceki veriler silinmesin ve üzerine yeni veri ekleyebilelim istersek, komutumuzu <strong><code>cat &gt;&gt; yeni3.txt</code></strong> şeklinde kullanarak; yeni gireceğimiz verileri girdikten sonra <strong><mark>Ctrl + D</mark></strong> tuş kombinasyonu ile dosyamızı yeni eklenmiş verileriyle birlikte kaydedip kapatabiliriz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/10-min.gif" class="responsive" ></p>
<p>Gördüğünüz gibi yeni eklediğimiz veri dosyamızın içine işlenmiş oldu üstelik eski veriler de yok olmadan.</p>
<p>Ayrıca yeri gelmişken kullanmış olduğumuz <strong><mark>&gt;</mark></strong> yönlendirme operatörü ile ilgili bir örnek daha yapalım ki kullanım alanının biraz daha farkına varmış olalım. Örneğin <strong><code>ls -ls</code></strong> çıktısının içeriğini "<em><strong>liste</strong></em>" adında bir dosya oluşturarak içerisine aktaralım. Bunun için <strong><code> ls -ls &gt; liste</code></strong> komutunu kullanabiliriz. Şayet yeni dosya oluşturmak istemiyorsak ve gireceğimiz veriler var olan dosyaya yazılsın istiyorsak o zaman <strong><mark>&gt;</mark></strong> operatörü yerine <strong><mark>&gt;&gt;</mark></strong> operatörünü kullanırsak yeni veriler dosyaya eklenmiş olur.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/11-min.png" class="responsive" >
Komutta açıklanacak bir durum yok zaten hepsi bildiğimiz komutlar. Burada asıl önemli olan <strong><mark>&gt;</mark></strong>  operatörünün kullanımıydı. Eğer anladıysak ne âlâ.. devam edelim.</p>
<p><strong><code>cat</code></strong> komutunun işlevlerine devam ediyoruz; şimdi ise sırada, bir dosyada yer alan verileri başka bir dosyaya kopyalamak var. Bunun için komutumuzu <strong><code>cat veri_alınan_dosya &gt; veri_alan_dosya</code></strong> şeklinde kullanıyoruz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/12-min.png" class="responsive" ></p>
<p>Komutumuzun kullanım şekilleri elbette bunlar ile sınırlı değil.
Belki defalarca söyledim ancak bu komut için de söylemem gerek; daha fazla detay için lütfen <strong>man kılavuz sayfasına</strong> göz atın.</p>
<h2>tac</h2>
<p>İsminden de anlamış olacaksınız ki <strong><code>tac</code></strong> komutu önce gördüğümüz <strong><code>cat</code></strong> komutunun tersi şekilde çıktı veriyor. Bu durumu daha iyi anlamak için karşılaştırmalı olarak verilen çıktıyı inceleyiniz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/13-min.png" class="responsive" ></p>
<h2>rev</h2>
<p>Hazır terslikten bahsetmişken <strong><code>rev</code></strong> komutundan da söz etmemek olmaz. Bu komut dizeleri sondan başa doğru çevirerek ters şekilde ekrana basıyor. Bu durum en iyi örnek ile açıklanır. Hatta <strong><code>cat</code></strong> komutu ile de karşılaştırırsak sonuç daha net oraya çıkacaktır.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/14-min.png" class="responsive" ></p>
<p>Çıktılarda görüldüğü gibi dosya içeriğinde yer alan ifadeler <strong><code>rev</code></strong> komutu sayesinde ters şekilde ekrana basılmış oldu.</p>
<p>"<em>Şimdi ben bu komutu nerede kullanacağım? neden öğrendim?</em>" demeyin. Bu konuya daha önce de değinmiştim, şimdi tekrar söylüyorum; burada öğrendiğimiz her komutu her zaman doğrudan kullanmayabilirsiniz, ancak yeri geldiğinde böyle bir komutun varlığından haberdar olarak gerektiğinde dokümantasyona bakmak suretiyle komutun kullanımına en kısa sürede ulaşabilirsiniz. Yani artık bu komutun varlığından haberdarsınız, eğer hatırlamak için bakmanız gerekirse burada olacak..</p>
<h2>echo</h2>
<p>Bu komutumuzu daha önce defaatle kullanmak durumunda kalmıştık hatırlarsanız. Kullandıkça da işlevinden bahsetmiştik ancak şimdi komutumuzu ele alarak biraz daha yakından bakmaya başlıyoruz.</p>
<p>Temel işlevi terminal ekranına istenilen bilgileri çıktı olarak göndermektir. Komutumuzu kullanırsak daha net anlaşılacaktır. Örneğin komut satırına "<strong>Merhabalar</strong>" yazdırmak isteyelim, bunun için komut satırına <strong><code>echo Merhabalar</code></strong> şeklinde komutumuzu girmemiz yeterli.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/15-min.png" class="responsive" ></p>
<p>"<strong>Merhabalar</strong>" çıktımızı almış olduk. <strong><code>echo</code></strong> komutu sadece ekrana basma işlevine sahip değil. Örneğin bir dosya oluşturup içerisine istediğimiz ifadeyi yazabiliriz. Bunun için komut satırına <strong><code>echo "yazılacak_ifade"&gt; dosya_adı</code></strong> şeklinde komutu giriyoruz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/16-min.png" class="responsive" ></p>
<p>Sırasıyla yaptığım işlemleri açıklayayım.</p>
<p>İlk önce <strong><code>cd Desktop</code></strong> komutu ile masaüstü konumuna geldim.</p>
<p>Daha sonra <strong><code>echo "Deneme Metni" &gt; deneme</code></strong> komutunu vererek masaüstü konumuna <strong><mark>deneme</mark></strong> isimli bir dosya oluşturarak içerisine "<em><strong>Deneme Metni</strong></em>" ifadesini yazmış oldum.</p>
<p><strong><code>ls</code></strong> komutu ile de bulunduğum konumdaki dosyaları listeleyerek içerisinde oluşturduğum "<strong>deneme</strong>" adlı dosyanın bulunup bulunmadığını teyit ettim.</p>
<p><strong><code>cat deneme</code></strong> ile de <strong><code>cat</code></strong>komutunun en temel kullanım işlevi olan içeriği ekran basma işlevini kullanarak oluşturduğum dosyanın içeriğine baktım.</p>
<p>Sonuç itibari ile her şey sorunsuz ilerledi ve finalde yeni oluşturmuş olduğum <strong><mark>deneme</mark></strong> isimli dosyanın içerisine "<em><strong>Deneme Metni</strong></em>" ifadesini yazdırmış oldum.</p>
<p>Ancak şöyle bir hatırlatmada bulunayım; eğer var olan bir dosyanın içeriğine yeni içerikler eklemek isterseniz daha önce de kullandığımız şekilde <strong><mark> &gt;&gt; </mark></strong> parametresini kullanın. <strong>Aksi halde dosya içeriğindeki her şey silinir ve yalnızca sizin son yazdığınız ifade kalır.</strong></p>
<p>Var olan dosya içeriğine yeni bir ifade eklemek için komutu <strong><code>echo "Yeni ifade" &gt;&gt; dosya_adı</code></strong> şeklinde girmemiz gerek.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/17-min.png" class="responsive" ></p>
<p>Şimdi <strong><code>echo</code></strong> komutunun <strong><code>ls</code></strong> komutu görevi gördüğü bir kullanıma değineceğiz.</p>
<p>Örneğin bulunduğumuz dizinde yer alan dosyaları görmek istersek komut satırına <strong><code>echo *</code></strong> şeklinde yazmamız halinde çıktı bizlere bulunduğumuz konumda yer alan dosyaları verir. Bu komut kullanımını <strong><code>ls</code></strong> komutu ile karşılaştırdığımızda daha net anlaşılacaktır.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/18-min.png" class="responsive" ></p>
<p><strong><mark> * </mark></strong> (<strong>yıldız işareti</strong>) joker karakteridir ve herhangi dosya dizin isimlerinin yerini tutar. Yani <strong><code>echo</code></strong> komutuna <strong><mark> * </mark></strong> karakteri eklediğimizde mevcut dizinde yer alan tüm dosya dizinler  <strong><mark>* </mark></strong> parametresi ile kapsanacağı için ne var ne yok listeleniyor. Bu duruma örnek olması açısından bulunduğumuz dizinde yer alan dosyalarda örneğin "<strong>list</strong>" adı ile başlayanları çıktı olarak almak istersek komut satırına <strong><code>echo liste*</code></strong> şeklinde komut vermemiz yeterlidir. (İleride ele alacağımız <em><strong>Joker karakter/wildcard</strong></em> konusundan bu karakterler açıklanmıştır.)</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/19-min.png" class="responsive" ></p>
<p>Son olarak <strong><code>echo</code></strong> komutunun kullanım şekillerinden olan, bir komutun çıktılarının <strong><code>echo</code></strong> komutu ile ekrana basılması var. Ancak doğrudan <strong><code>echo komut</code></strong> şeklinde yazılan komutlar istenmeyen bir sonuç çıkaracaktır. Verdiğimiz komutun çıktılarını alma işlemini gerçekleştirebilmek için <strong><code>echo</code></strong> komutunun bu iş için kullanım özelliklerinden olan iki farklı seçenek bulunuyor. Bunlardan biri <strong>ters tırnak</strong> <strong><mark>'</mark></strong> işaretini diğeri ise <strong><code>$(komut)</code></strong> parametre bütünüdür. Bunları sırayla görelim.</p>
<p>İlk olarak <strong>ters tırnak</strong> işaretli olan kullanımı ele alalım.</p>
<p>Ters tırnak işaretini oluşturmak için Türkçe klavyede <strong><mark>AltGr + ,</mark></strong> (<strong>AltGr ile birlikte virgül tuşuna basmak gerek</strong>)tuş kombinasyonunu kullanabiliriz. Komutun kullanımını için ise istediğimiz komutu tırnak içerisinde <strong><code>echo</code></strong> komutunun yanında kullanmak üzere  <strong><code>echo 'komut'</code></strong> şeklinde yazıyoruz.</p>
<p>Hemen bu kullanım ile ilgili bir örnek yapalım ve <strong><code>ls</code></strong> komutunun çıktılarını <strong><code>echo</code></strong> komutu yardımı ile basalım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/20-min.png" class="responsive" ></p>
<p>Ve ikinci yol olan <strong><code>$(komut)</code></strong> parametre bütünü; yine <strong><code>ls</code></strong> komutu için örneklendirilecek olursa, kullanımı <strong><code>echo $(ls) </code></strong> şeklinde komut parantez içine gelecek şekilde olmalıdır.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/21-min.png" class="responsive" ></p>
<p>Sonuç itibari ile ilk <strong><code>echo ls</code></strong> komutunun çıktısı olan "<strong>ls</strong>" ifadesi bizim almak istediğimiz çıktıyı bizlere vermedi. Yani bu kullanım bizim yapmak istediğimiz iş olan, komutun çıktılarının ekrana bastırılması için doğru bir kullanım değildi. Doğru kullanım şekli ise ikinci ve üçüncü komut olan <strong><code>echo 'ls'</code></strong>, <strong><code>echo $(ls)</code></strong> şeklindedir. Bu komutların çıktısı istediğimiz şekilde, yani <strong><code>ls</code></strong> komutunun çıktısını(bulunduğumuz dizinde yer alan dosyaların bilgisi) ekrana basacak şekilde bizlere verdi. Sözü edilen durumu aşağıdaki çıktıyı inceleyerek bir bütün halinde kavrayabilirsiniz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/22-min.png" class="responsive" ></p>
<h2>more</h2>
<p>Şimdiye kadar öyle ya da böyle terminal üzerinden dosya okuma işlemi yapmamıza yardımcı olan komutlar gördük. Bu komutumuz da aynı şekilde metin dosyalarını terminal üzerinden okumamıza olanak sağlayan bir komuttur.</p>
<p>Örneğin daha önce de içeriğini okuyup değişiklik yapmış olduğumuz dosya olan <strong><mark>profile</mark></strong> dosyasının içeriğini <strong><code>more</code></strong> komutu yardımı ile okuyalım.</p>
<p>Bunun için <strong><mark>/etc/profile</mark></strong> konumunda bulunan dosyamı <strong><code>more</code></strong> komutu ile açmak üzere konsola <strong><code>more /etc/profile</code></strong> şeklinde konsola yazarak <strong><mark>profile</mark></strong> dosya içeriğini okumaya teşebbüs ediyorum.
Komutumuzun ardından terminal ekranında karşımıza <strong><mark>profile</mark></strong> dosyasının içeriği aşağıdaki gibi geldi.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/23-min.png" class="responsive" ></p>
<p>Çıktıda görüldüğü gibi dosyanın içeriği ancak terminal ekranına sığacak şekilde görüntüleniyor. Hatta alt kısımda <strong>--More--(77%)</strong> şeklinde yazan yazı bizlere içeriğin devamı olduğunu belirtiyor. Eğer devamını okumak istersek <strong><mark>enter</mark></strong> tuşuna basarak adım adım alt satırlara bakabiliriz. Ayrıca <strong><mark>space</mark></strong> tuşu ile de sayfa sayfa atlayarak içeriğe göz atabiliriz. Eğer atladığınız sayfadan bir önceki sayfaya geri dönmek istersek <strong><mark>b</mark></strong>(<strong>back/geri</strong>) tuşunu, şayet dosya içeriğini görüntüleyen bu ekranı kapatmak istersek ise <strong><mark>q</mark></strong>(<strong>quit/çıkış</strong>) tuşunu kullanmamız yeterli.</p>
<h2>less</h2>
<p>Bu komutumuz da üst kısımda açıkladığımız <strong><code>more</code></strong> komutu ile aynı işlevdedir. Ayrıntısını merak ederseniz man sayfasına göz atmanız yeterli olacaktır.</p>
<p>Ben yine de <strong><code>less</code></strong> komutu ile <strong>profile</strong> dosyasının içeriğinin okunduğu şeklini aşağıya bırakıyorum. Eğer <strong><code>more</code></strong> komutunda bir problem yaşamadıysanız bu komut kullanımında da kesinlikle yaşamazsınız.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/24-min.png" class="responsive" ></p>
<h2>head-tail</h2>
<p>Aslında komutların isimleri yani <strong>head(kafa/baş)</strong> ve <strong>tail(kuyruk)</strong> bizlere komut hakkında az çok bilgi veriyor. Şöyle ki bir dosyanın sadece baş kısmında ilk 10 satırı görüntülemek istersek <strong><code>head</code></strong> şayet son 10 satırı görüntülemek istersek ise <strong><code>tail</code></strong> komutunu kullanırız. Ayrıca bu komutlar özel parametre alarak istenildiği sayıda baştan veya sondan olmak üzere istenilen satırların görüntülenmesine olanak sağlar. Daha iyi anlamak adına hemen kullanımlarına geçelim.</p>
<p>Dosya içeriğinin ilk 10 satırını görüntülemek için <strong><code>head dosya_adı</code></strong> şeklinde komutumuzu kullanıyoruz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/25-min.png" class="responsive" ></p>
<p>Şimdi burada 10 satır içerik yok gibi gelebilir ancak dosya içerisindeki boş satırlar da bu 10 satıra dahil olduğundan çıktıyı boş satırlar ile saydığınızda tam olarak 10 satırın görüntülendiğini göreceksiniz.</p>
<p>Dosya içeriğinin son 10 satırını görüntülemek için <strong><code>tail dosya_adı</code></strong> şeklinde komutumuzu kullanıyoruz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/26-min.png" class="responsive" >
Şimdi istediğimiz sayıda baştan veya sondan dizinleri görüntüleyelim. Ben örnek olması açısından <strong>baştan 6 sondan 2</strong> satırı görüntülemek üzere komutumu veriyorum. Komutun kullanımı <strong><code>head -n 6</code></strong> ve <strong><code>tail -n 2</code></strong> şeklinde.</p>
<p><strong>Baştan 6 satırın çıktıları.</strong></p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/27-min.png" class="responsive" ></p>
<p><strong>Sondan 2 satırın çıktıları.</strong></p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/28-min.png" class="responsive" ></p>
<h2>nl</h2>
<p>Bu komutun işlevi satırları numaralandırarak çıktı vermektir. Hemen görelim.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/29-min.png" class="responsive" ></p>
<p>Çıktıda da görüldüğü üzere dosya içeriğinde yer alan ifadeler satır satır numaralandırılarak ekrana basılmış oldu.</p>
<p>Ayrıca eğer listelenen içerik uzunsa bir önceki öğrendiğimiz <strong><code>head-tail</code></strong> komutları yardımı ile bu alanı düzenli şekilde sınırlandırabiliriz.</p>
<h2>sort</h2>
<p>Dosya çıktılarının alfabetik olarak düzenlenmesini sağlar. Örnek üzerinden devam edelim. Ben <strong><mark>isimler.txt</mark></strong> adında bir dosya oluşturdum ve içerisine karışık olarak isimler ekledim.
Ve bu isimleri alfabetik sıraya dizmek için <strong><code>sort isimler.txt</code></strong> komutunu kullandım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/30-min.png" class="responsive" ></p>
<p>Eğer ters alfabetik şekilde yani <strong>z den a ya doğru</strong> sıralamak istersek <strong><code>-r</code></strong> parametresi kullanılır.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/31-min.png" class="responsive" ></p>
<h2>paste</h2>
<p>Örneğin iki dosyanın içeriğini aynı anda yan yana olacak şekilde komut satırında listelemek istersek, bu işi yapmamızı <strong><code>paste </code></strong> komutu sağlıyor. Kullanımı <strong><code>paste dosya1 dosya2</code></strong> şeklindedir.</p>
<p>Ben <strong><mark>yaşlar.txt</mark></strong> ve <strong><mark>isimler.txt</mark></strong> adlı dosyaları aynı anda yana yana görüntülemek adına komut satırına <strong><code>paste isimler.txt yaşlar.txt</code></strong> komutunu verdim.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/32-min.png" class="responsive" ></p>
<h2>tee</h2>
<p>Yazmak istediğimiz ifadeleri hem komut satırına yansıtıp hem de bu ifadelerim bir dosya içerisine kayıt olmasını isterseniz kullanacağınız komut <strong><code>tee</code></strong> komutu olacaktır.</p>
<p>Örnek üzerinden devam edelim.</p>
<p><strong><code>tee metin</code></strong> komutu ile "<strong>metin</strong>" isminde bir dosya açıyorum ve içerisine birtakım ifadeler ekliyorum daha sonra ekleme işlemim bittiğinde dosyayı kaydederek kapatmak üzere <strong><mark>Ctrl + D</mark></strong> tuş kombinasyonunu uyguluyorum. En son oluşturmuş olduğum dosya içeriğine bakmak üzere <strong><code>cat</code></strong> komutunu kullanıyorum.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/33-min.png" class="responsive" ></p>
<p>Çıktıda da görüldüğü üzere terminal ekranında yazdığımız her bir satır tekrar ederek konsola basıldı ve sonuçta oluşturmuş olduğumuz "<strong>metin</strong>" isimli dosyanın içeriği de yazmış olduğumuz ifadeler ile dolmuş oldu.</p>
<h2>cmp</h2>
<p>Bu komut sayesinde dosyalar arasından karşılaştırma yapmamız mümkün.</p>
<p>Örneğin ben <strong><mark>isimler.txt </mark></strong> dosyasını kopyaladım ve 5. satırındaki ismi değiştirdim. Ve bu iki dosyayı <strong><code>cmp</code></strong> komutu ile kıyasladım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/34-min.png" class="responsive" ></p>
<p>İki dosyanın da içeriğini <strong><code>cat</code></strong> komutu ile yazdırdık görüldüğü üzere iki dosya arasındaki fark, bir dosyada <em>mehmet</em> ismi yerine <em>enes</em> isminin yer almasıdır. <strong><code>cmp</code></strong> komutunun çıktısında da bu durum farklı olan satır ve bayt bilgisi verilerek ifade edeliyor.</p>
<h2>grep</h2>
<p>Bu komut en çok kullanılan terminal komutları içerisinde bulunuyor. Bu komutumuzu bizler de oldukça sık kullanıyor olacağız. Dosya ya da komut çıktısında bir ifade aramak için yani bir nevi filtreleme işlemi için <strong><code>grep</code></strong> komutunu kullanabiliriz. Komutun kullanım şekillerini örnekler ile açıklamaya devam edelim.</p>
<p>Eğer bir dosya içerisindeki herhangi bir kelimeyi sorgulamak istersek komutumuzu <strong><code>grep "aranacak_ifade" dosya_adı</code></strong> şeklinde komut satırına giriyoruz. Ben basit bir örnek olması açısından <strong><mark>isimler.txt</mark></strong> dosyası içerisinde "hasan" ismi var mı diye kontrol etmek üzere konsola <strong><code>grep "hasan" isimler.txt</code></strong> komutunu veriyorum.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/35-min.png" class="responsive" ></p>
<p>Arama işleminde, Linux sistemi gereği <strong>büyük küçük harf duyarlılığına sahip olduğundan</strong>(Hatırlarsanız daha önce bu durumu test etmiştik.) "<strong>hasan</strong>" şeklinde arama yaptığımızda diğer büyük küçük haldeki anahtar kelimeler çıktıda basılmayacaktır. Eğer bu küçük büyük harf duyarlılığı dışında arama yapmak istersek <strong><code>-i</code></strong> parametresini kullanabiliriz.  Bu durumu gözlemlemek için büyük küçük harflerden oluşan kelimelerin olduğu bir dosya üzerinde <strong><code>grep</code></strong> komutunu kullanalım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/36-min.png" class="responsive" ></p>
<p>Eğer arama işlemini tek dosya yerine bulunduğumuz dizin içerisindeki tüm dosyaları kapsayacak şekilde gerçekleştirmek istersek wildcard yani genel kapsama işlevinde olan joker <strong><code>*</code></strong> karakteri yardımıyla bu işlemi gerçekleştirebiliriz.</p>
<p>Hemen örneklere geçelim. <strong>hasan</strong> ismini masaüstü konumundayken aratıyorum. Bunun için <strong><code>grep "hasan" *</code></strong> komutunu konsola verdim.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/37-min.png" class="responsive" ></p>
<p>Gördüğünüz gibi çıktı bize içerisinde "<strong>hasan</strong>" ifadesi geçen tüm dosyaları verdi.</p>
<p>Çıktıda aradığımız ifadenin hangi dosyada yer aldığını bulmuş olduk. Ayrıca yukarıdaki komutu <strong><code>grep -r "hasan" *</code></strong> şeklinde de yazabilirdik. Genellikle de bu 2. komut kullanılıyor ancak hangi şekilde kullanacağınızı seçmek size kalmış dilediğiniz kullanabilirsiniz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/38-min.png" class="responsive" ></p>
<p>İkinci kullanım şeklinde ilkinden farklı olarak "<em><strong>grep: yeni_dizin: Bir dizin</strong></em>" gibi bir çıktı almadık.</p>
<p>Wildcardlardan söz etmişken dosya içerisinde arama işleminin başka bir kullanım şekline de değinelim isterim. Eğer aranacak kelime belirli bir isim ile başlayan dosyalar içerisinde aranacaksa bunu wildcard(joker) yardımıyla özellikle belirtebiliriz.</p>
<p>Kullanımı <strong><code>grep "aranacak_ifade" dosya_adı_başlangıcı*</code></strong> şeklindedir. Ben ilk önce masaüstünde yer alan dosyaları listeledim daha sonra "<strong>hasan</strong>" ifadesini aramaya koyuldum. İlk önce "<strong>metin</strong>" ismi ile başlayan belgelerde <strong><code>grep "hasan" metin*</code></strong> komutunu kullanarak aradım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/39-min.png" class="responsive" ></p>
<p>Ancak çıktıda da görüleceği gibi "<strong>hasan</strong>" ifadesi "<strong>metin</strong>" ismi ile başlayan belgeler içerisinde yer almıyormuş ki komut çıktısı bize hiç bir sonuç vermedi.</p>
<p>Bende "<strong>hasan</strong>" ismini bu sefer "<strong>isimler</strong>" adıyla başlayan belgeler içerisinde aramak için <strong><code>grep "hasan" isimler*</code></strong> komutunu kullandım. Bunun neticesinde komut satırı bize "<strong>hasan</strong>" isminin geçtiği belgelerin yerini vermiş oldu.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/40-min.png" class="responsive" ></p>
<p>Buradaki asıl kullanım amacı; komutu, belirli isimlere sahip olan dosyalar içerisinden anahtar kelimeyi aramak üzerine sınırlandırmak.</p>
<p>Bunların dışında arama sonucunun görüntülenmesini de sınırlandırabiliriz;
Örnek olması açısından "<strong>filozof</strong>" isimli dosyadan "<strong>jo</strong>" ile başlayan isimleri listeliyorum.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/41-min.png" class="responsive" ></p>
<p>Arama sonucu sonrasında kaç satır gözükeceğini <strong><code>-A</code></strong> parametresi sayesinde <strong><code>grep -A satır_sayısı "aranacak_ifade" dosya_adı</code></strong> şeklinde komut girerek sağlarız.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/42-min.png" class="responsive" ></p>
<p>Sonucun üzerindeki kaç satırın gözükeceğini <strong><code>-B</code></strong> parametresi sayesinde <strong><code>grep -B satır_sayısı "aranacak_ifade" dosya_adı</code></strong> şeklinde komut girerek sağlarız.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/43-min.png" class="responsive" ></p>
<p>Baştan ve sondan kaç satır görüntüleneceğini ise <strong><code>-C</code></strong> parametresi sayesinde <strong><code>grep -C satır_sayısı "aranacak_ifade" dosya_adı</code></strong> şeklinde komut girerek sağlarız.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/44-min.png" class="responsive" ></p>
<p>Şimdi ise sıklıkla kullanılan <strong>pipe</strong> ile <strong><code>grep</code></strong> kullanımına bakalım.
Pipe nedir diyecek olursanız kabaca iki işlemi(process) birbirine bağlayan <strong><code>|</code></strong> görünümündeki yardımcı argüman diyebiliriz. Zaten daha önce de iki işlemin birbirine bağlanması gereken durumlarla karşılaşmış ve pipe kullanmıştık.</p>
<p><strong><code>grep</code></strong> ile kullanımına geçecek olursak örneğin masaüstünde yer alan dosyalardan yalnızca "<strong>metin</strong>" isimli olanları listelemek isteyelim. Bunun için ilk olarak masüstünde yer alan dosyalarımızı listelemek üzere komut satırına <strong><code>ls</code></strong> daha sonra ise <strong><code>ls</code></strong> komutundan gelecek olan çıktıları pipe yardımı ile <strong><code>grep</code></strong> komutuna bağlayarak listelenen bütün bu dosyalar içerisinden sadece "<strong>metin</strong>" adı geçenleri filtreleyebilelim..</p>
<p>Bu işlemi gerçekleştirmek için <strong><code>ls | grep "metin"</code></strong> komut bütününü kullanıyorum.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/45-min.png" class="responsive" ></p>
<p><strong><code>grep</code></strong> komutunun kullanım şekli ve alanı elbette bu kadar ile sınırlı değil ancak sizler daha fazla bilgiye nasıl ulaşacağınızı biliyorsunuz.</p>
<h2>find</h2>
<p><strong><code>find</code></strong> komutu da hemen hemen daha önce görmüş olduğumuz <strong><code>locate</code></strong> komutu ile aynı görevi görüyor. Örneğin, isminin birazını bildiğimiz ama dosya dizinini tam olarak hatırlamadığımız dosyaları bulmamıza yardımcı oluyor.</p>
<p>Komut kullanım kalıbı <strong><code>find dosya_yolu -name aranacak_ifade</code></strong> şeklindedir. Tam kullanım şekli için aşağıdaki örneği inceleyebilirsiniz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/46-min.png" class="responsive" ></p>
<p>Çıktıda <strong><mark>etc</mark></strong> konumda yer alan içerisinde "<strong>local</strong>" ifadesi geçen dosyalar komutumuz sayesinde listelenmiş oldu. Ancak aradığımız şeyi bulmak adına değiştirilme tarihi, boyut, dosya-dizin gibi ayrıntıları belirterek çıktıları daha spesifik şekilde sınırlandırabiliriz. Bazı özel arama parametreleri açıklayalım hemen.</p>
<ul>
<li><strong>type f :</strong> Yalnızca dosyalar.</li>
<li><strong>type d :</strong> Yalnızca dizinler.</li>
<li><strong>size +500k :</strong> 500 KB'tan büyük olan dosyalar.</li>
<li><strong>size -500k :</strong> 500 KB'tan küçük olan dosyalar.</li>
<li><strong>ctime 10 :</strong> Tam olarak 10 gün önce değişikliğe uğramış dosya/dizinler.</li>
<li><strong>ctime -10 :</strong> 10 günden daha kısa bir süre önce değişikliğe uğramış dosya/dizinler.</li>
<li><strong>ctime +10 :</strong> 10 günden daha uzun bir süre önce değişikliğe uğramış dosya/dizinler.</li>
<li><strong>perm 755 :</strong> Yalnızca erişim izni 755 olan dosya/dizinler.
Örnek olması açısından yukarıdaki arama parametrelerinin ilk ikisinin çıktılarını aşağıya ekliyorum.</li>
</ul>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/47-min.png" class="responsive" ></p>
<h2>xargs</h2>
<p><strong><code>xargs</code></strong> komutunun görevi kabaca kendisinden önce verilen girdi verilerini kendisinden sonrakine tek tek aktarmaktır. Biliyorum böyle denilince hiçbir şey anlaşılmıyor. O yüzden <strong><code>xargs</code></strong> komutunu <strong><code>find</code></strong> komutuyla birlikte kullanarak örnek üzerinden komutumuzu ve kullanım mantığını açıklamış olalım.</p>
<p>Örneğin <strong><mark>-min.jpg</mark></strong> uzantılı bir resim dosyasını araştırıp daha sonra bulduğumuz bu dosyayı silelim. Ben duvar kağıdı için daha önce internetten bir <strong><mark>-min.jpg</mark></strong> uzantılı bir resim indirmiştim. Bu resim hem <strong>indirilenler(downloads)</strong> hem de <strong>resimler</strong> konumunda yer alıyor, söylediğim gibi aslında dosyanın konumunu biliyorum ancak komutun kullanımını denemek üzere dosyanın konumunu bilmiyormuşçasına bir test edelim. Testimizde <strong><mark>root</mark></strong> dizinindeki <strong><mark>-min.jpg</mark></strong> uzantılı dosyaları araştıralım ve silelim.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/48-min.png" class="responsive" ></p>
<p>Çıktıda da görüldüğü gibi <strong><mark>-min.jpg</mark></strong> uzantılı resim dosyalarını tek tek bulup silmeden önce, çıktıda belirtilen konumlarda bulunuyorlardı. Ancak arama ve tek tek otomatik olarak silme işlemini gerçekleştirmemiz ile birlikte dosyalar silindi. Silinme durumunu da tekrar arama işlevindeki <strong><code>find</code></strong> komutunu vererek teyit etmiş olduk.</p>
<p>Komutumuzun işleyişi tam olarak şöyle oldu;</p>
<p><strong><code>find /root -name *-min.jpg</code></strong> komutu ile <strong><mark>root</mark></strong> dizini altındaki tüm <strong><mark>-min.jpg</mark></strong> uzantılı dosyaları listeledik.</p>
<p>Bu listelenen dosya konum ve varlık bilgilerini <strong><code>xargs</code></strong> komutuna <strong><code>pipe( | )</code></strong> argümanı sayesinde aktardık.</p>
<p><strong><code>xargs</code></strong> komutu ise eline geçen bu bilgiler sayesinde dosyanın konumunu saptayarak tek tek silme işlemini gerçekleştirebildi.</p>
<p><strong><code>xargs</code></strong> komutu <strong><code>exec</code></strong> isimli başka bir komuta benzer şekilde çalışmaktadır. Merak edip öğrenmek isteyen arkadaşlar ayrıca <strong><code>exec</code></strong> komutuna bakabilirler.</p>
<h2>Dosya Kopyalama-Taşıma-Silme İşlemleri</h2>
<p>Bu kısımda dosyaları kopyalama taşıma ve silme gibi işlemleri ele alacağız. Zaten kullanacağımız komutlar kısa oldukları için kullanımı ve akılda kalması çok kolay. İlk olarak dosya kopyalama işlemi ile anlatıma başlayalım.</p>
<h3>cp</h3>
<p><strong><code>cp</code></strong> komutu kopyalama işlevindedir. Kullanımı <strong><code>cp kaynak hedef</code></strong> şeklindedir. Örnek üzerinden açıklayalım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/49-min.png" class="responsive" ></p>
<p>Komutumuzu açıklayacak olursak;</p>
<p><strong>Desktop</strong> dizinindeyken <strong><code>ls</code></strong> komutu ile bulunduğumuz dizindeki dosyaları listeliyoruz. Ve çıktıda da görüldüğü üzere masaüstünde "<strong>filazof</strong>" isimli bir belge bulunuyor.</p>
<p><strong><code>cd yeni_dizin</code></strong> komutuyla  <strong><mark> yeni_dizin </mark></strong> konumuna gidiyoruz.</p>
<p><strong><code>ls</code></strong> komutu ile buradaki dosyaları listeliyoruz. Bu dizinde ise yalnızca "<strong>yeni</strong>" isimli bir klasör mevcut.("<strong>filazof</strong>" isimli dosyanın bu konumda bulunmadığını teyit etmiş olduk.)</p>
<p><strong><code>cd ..</code></strong> komutu ile bir önceki dizine dönüyoruz.
"filazof" dosyasını <strong><mark>yeni_dizin</mark></strong> konumuna taşımak üzere <strong><code>cp filazof yeni_dizin</code></strong> şeklinde komutumuzu kullanıyoruz.</p>
<p>Daha sonrasında ise <strong><code>cd yeni_dizin</code></strong> komutu ile yeni_dizin konumuna gidip <strong><code>ls</code></strong> komutu yazarak "<strong>filazof</strong>" isimli dosyamızın kopyalandığını teyit etmiş oluyoruz.</p>
<p>Eğer bir dosyayı A dizininden B dizinine taşırsak ve B dizini içerisinde A dizininden taşıdığımız belge ile aynı isimde dosya varsa, taşıdığımız dosya mevcut konumda bulunan aynı isimdeki eski dosyanın üzerine yazılacaktır. Bu da B konumunda var olan eski dosyanın önceki içeriğinin yok olması demek. Böyle talihsiz bir durum yaşamamak için <strong><code>cp</code></strong> komutunu kullanmadan önce <strong><code>-i</code></strong> parametresini de eklememizde fayda var. Bu parametre <strong><code>cp</code></strong> komutunun aynı isimli bir dosya ile karşılaşma durumunda bize onay sormasını sağlayacaktır.</p>
<p>Anlatılanları daha iyi anlamak adına hemen bir örnek yapalım. Daha önceden <strong><mark>yeni_dizin</mark></strong> konumuna taşımış olduğumuz "<strong>filazof</strong>" dosyasını <strong><code>-i</code></strong> parametresini kullanarak tekrar <strong><code>cp</code></strong> komutu ile taşımaya çalışalım.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/50-min.png" class="responsive" ></p>
<p>Çıktıda da görüldüğü gibi <strong><code>-i</code></strong> parametresini kullanarak yazdığımız kopyalama komutu bize "***cp: 'Desktop/merhaba''ın üzerine yazılsın mı? ***" şeklinde bir uyarıda bulundu ve bizden onay bekledi.</p>
<p>Elbette bu işlemleri çoklu dosya taşıma için de kullanabiliriz.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/51-min.png" class="responsive" ></p>
<p>Hangi komutu neden kullandık zaten bir önceki örneğe benzer olduğu için tekrar açıklamıyorum. Çıktıları inceleyerek çok rahat şekilde anlayabilirsiniz.</p>
<p>Eğer o anda çalıştığımız dizine başka bir konumdan dosya kopyalamak istersek komutumuzu <strong><code>cp kopyalanacak_dosya_konumu .</code></strong> şeklinde kullanabiliriz. <strong>Nokta( . )</strong> bizim o anda bulunduğumuz çalışma konumunu ifade ediyor. Örneği incelediğinizde her şey daha net anlaşılacaktır.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/52-min.png" class="responsive" ></p>
<p>Görüldüğü üzere kopyalanacak olan dosyanın konumunu belirttik ancak bulunduğumuz konuma yani kopyalamak istediğimiz konumun direk adresini belirtmemize gerek kalmadı. Bunun yerine bulunduğumuz konumu temsil eden <strong><code>.</code></strong>(nokta) kullanmamız dosyanın kopyalanmasını sağladı.</p>
<p>Eğer bulunduğumuz konumdan bir üst konuma kopyalamak istersek komutu <strong><code>cp dosya_adresi ..</code></strong> şeklinde kullanmamız yeterli olacaktır.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/53-min.png" class="responsive" ></p>
<p>Çıktıları karşılaştırarak dosyayı bir önceki dizine kopyalamayı (iki nokta) <strong><code>..</code></strong> ile kolaylıkla yapabildiğimizi görebilirsiniz.
(Eğer "deneme" isimli dosyayı kopyalarken kullandığımız komutta yer alan, dosyanın konumunu belirtme kısmı kafanızı karıştırdıysa belirteyim; çıktıda kopyalanan konumda yer alan <strong><mark>~</mark></strong> işareti <strong>ana dizin adresini</strong> yani <strong>root</strong> kullanıcısı için <strong><code>/root</code></strong> konumunu belirtiyor. "<strong>deneme</strong>" isimli dosya bu konumda olduğu için direk bu şekilde bir kullanımı tercih ettim. Bunun yerine <strong><code>cp /root/deneme ..</code></strong> komutunu da kullanabilirdim.)</p>
<h3>mv</h3>
<p>Bu komut dosya taşıma ve uzantı değiştirme gibi işlevlere sahiptir. Dosya taşıma işlevi tıpkı <strong><code>cp</code></strong> komutunda olduğu gibidir. Yani komutun kullanımı <strong><code>mv dosya_konumu taşınacak_konum</code></strong> şeklindedir.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/54-min.png" class="responsive" ></p>
<h3>rm</h3>
<p>Dosya dizin silme işlevinde kullandığımız komuttur. Kullanımı <strong><code>rm silinecek_dosya_dizin</code></strong> şeklindedir.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/55-min.png" class="responsive" ></p>
<p>Dosyalar tekil olarak silinebileceği gibi çoklu silme işlemi de gerçekleştirilebilir. Hatta daha önce gördüğümüz joker karakterleri de kullanırsak isim, uzantı gibi filtrelere göre sınırlandırarak toplu dosya silme işlemi gerçekleştirebiliriz. Örnek olması açısından masaüstünde yer alan 2 adet <strong><mark>.py</mark></strong> uzantılı dosyayı tek seferde <strong><code>rm *.py</code></strong> komutu ile siliyorum.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/56-min.png" class="responsive" ></p>
<p>Joker karakterlerin kullanım alanları oldukça geniştir. Sizler de ihtiyacınıza göre filtreleme yaparak bu işlemleri istediğiniz doğrultuda gerçekleştirebilirsiniz.(Bu konuyu detaylıca ileride <a href="../web/10.html">Joker Karakterler</a> kısmında ele alacağız.)</p>
<h3>shred</h3>
<p>Bu komut sayesinde dosyalarımızı daha güvenli şekilde silebiliriz. <strong><code>shred</code></strong> komutu dosyanın içerisine rastgele bitler yazarak dosyanın okunmaz hale gelmesini sağlıyor. Parametresiz kullanımda dosyaya 3 kez rastgele bit eklerken <strong><code>n</code></strong> parametresini kullanarak bu eklenecek olan rastgele bit sayısını istediğimiz doğrultuda düzenleyebiliyoruz. Eğer yapılan işlemi komut satırından takip etmek istersek <strong><code>v</code></strong> parametresini de kullanabiliriz. Ayrıca <strong><code>u</code></strong> parametresini kullanmamız halinde dosya işlem sonrasında silinir.</p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/57-min.png" class="responsive"></p>
<p><img src="img/6-%20Dosya%20%C4%B0%C5%9Flemleri/58-min.png" class="responsive"></p>
	<h1></h1>
<center>
	<h1>Geri Bildirimde Bulunun</h1>
<p>Sizlere daha verimli bir kaynak sunabilmemiz için, uygulamada veya dokümantasyonlarda yer alan tüm hata ve eksiklerimizi bize bildirebilirsiniz.	</p>
	<div class="checkbox mb-3">
                          
			<a href="../bildirim.html" class="btn btn-danger">Geri Bildirimde Bulunun</a>

      </div></center>
	
</article>
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>


<script type="text/javascript" src="js/jquery1.min.js"></script>

<script type="text/javascript" src="js/fluidtextresizer.js">



</script>

<script type="text/javascript">

var mytextsizer=new fluidtextresizer({
	controlsdiv: "sizecontroldiv", 
	targets: ["body"],
	levels: 2,
	persist: "session",
	animate: 0 
})

</script>
<script>
    function dark() {
        if (document.body.style.backgroundColor == 'rgb(255, 255, 255)') {

                document.body.style.backgroundColor = '#E9E7DB';
				document.body.style.color='#000';
        }
        else {
                document.body.style.backgroundColor = 'rgb(255, 255, 255)';
				document.body.style.color='#000';
        }
    }
    </script>
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script  src="js/index.js"></script>

</body>

</html>

